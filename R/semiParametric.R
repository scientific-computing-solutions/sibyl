##' @include survivalData.R
NULL

setOldClass("coxph")
setOldClass("survfit")

##' SemiParametric class definition
##' @details Class storing the fitted Cox semi-parametric model and the
##' Kaplan Meier estimate (from survfit) for a given subgroup and endpoint
##' for a SurvivalData object.
##' @slot cox (coxph) The Cox model fit for the given subgroup and endpoint fitted using \code{coxph}
##' and no stratifiation or covariate variables
##' @slot coxWithStrata (coxph) The Cox model fit for the given subgroup and endpoint fitted using \code{coxph}
##' and the selected stratifiation and covariate variable. If no strata included then this is the same as slot cox
##' @slot km (survfit) The Kaplan-Meier estimator associated with the given subgroup and endpoint
##' generated by calling \code{survfit}. Note this estimator does NOT include the covariates
##' and strata included with the Cox model fit
##' @slot survData (SurvivalData) object used when fitting the models. NOTE: if a subgroup
##' was selected when creating this object then only subjects in the given subgroup will be
##' included in this object
##' @slot subgroup (character) which subgroup the SemiParametricModel is associated with (or \code{NA}
##' if not associated with any)
##' @slot endPoint (character) which endpoint the SemiParametricModel is associated with
##' @slot covariates (character vector) names of covariates used when fitting the Cox model
##' @slot strata (character vector) names of covariates to be used to stratify the Cox model fit
##' @slot endPointDef (list) defines name, time and censor column for the fitted
##'       endpoint
##' @seealso \code{fitSemiParametric} for further information
##' @export
setClass("SemiParametricModel",
         slots = list(cox="coxph",
                      coxWithStrata="coxph",
                      km="survfit",
                      survData = "SurvivalData",
                      subgroup = "character",
                      endPoint = "character",
                      covariates="character",
                      strata="character",
                      endPointDef="list"))

##' Method to fit semi-parametric model (Cox) and Kaplan-Meier
##' estimator to a SurvivalData object
##' @rdname fitSemiParametric-methods
##' @name fitSemiParametric
##' @param object (SurvivalData) The object to fit the semi-parametric model
##' and calculate the KM estimator
##' @param ... additional argument
##' @export
setGeneric( "fitSemiParametric", function(object,...)
  standardGeneric("fitSemiParametric"))




##' @name fitSemiParametric
##' @aliases fitSemiParametric,SurvivalData-method
##' @rdname fitSemiParametric-methods
##' @param endPoint (character) which endpoint the SemiParametricModel is associated with
##' @param subgroup (character) which subgroup the SemiParametricModel is associated with (or \code{NA}
##' if not associated with any)
##' @param covariates (character vector) names of covariates used when fitting the Cox model if any
##' @param strata (character vector) names of covariates to be stratified when fitting the Cox model
##' @export
setMethod("fitSemiParametric", signature(object="SurvivalData"),
  function(object, endPoint, subgroup = as.character(NA), covariates=character(0), strata=character(0)){


    if (!all(vapply(covariates, is.character, FUN.VALUE = TRUE))){
      stop("covariates must be a vector of character strings")
    }
    hasCovariates(object, covariates)

    if (!all(vapply(strata, is.character, FUN.VALUE = TRUE))){
      stop("strata must be a vector of character strings")
    }
    hasCovariates(object, strata)


    #validate endpoint and subgroup
    if (!is.character(endPoint) || length(endPoint) != 1){
      stop("endPoint must be a character string")
    }

    #endPoint matches one of the known endpoints (object@endPoints)
    # Look up relevant column names for the specified endpoint
    if(!endPoint %in% names(object@endPoints)){
      stop("Invalid endpoint argument, must be one of: ", paste(names(object@endPoints), collapse=", "))
    }

    if (!is.na(subgroup) && (!is.character(subgroup) || length(subgroup) != 1)){
      stop("subgroup must be either NA or a character string")
    }


    allowedSubgroups <- listColumnDefSlot(object@subgroupDef,"columnName")
    if(!is.na(subgroup) && !subgroup %in% allowedSubgroups){
      stop(paste("subgroup argument must be one of: ",paste(allowedSubgroups, collapse = ", ")))
    }

    # Look up relevant column names for the specified endpoint
    endPointDef <- object@endPoints[[endPoint]]

     # Create new SurvivalData object with data for this subgroup only
    survData <- object
    survData@subject.data <- extractSubgroup(object@subject.data, subgroup)

    # Check there is data on all arms, after subsetting
    armCol <- survData@armDef@columnName
    armValues <- levels(survData@armDef@categories)
    hasData <- vapply(armValues,
                      function(a){any(survData@subject.data[, armCol] == a)},
                      FUN.VALUE = FALSE)
    if (!all(hasData)){
      stop(paste0("The following arms contain no data in subgroup '", subgroup, "': ",
                  paste0(armValues[!hasData], collapse = ", ")))
    }

    # Check each arm has events
    censorCol <- endPointDef[["censorCol"]]
    hasEvents <- vapply(armValues,
                        function(a){any(survData@subject.data[survData@subject.data[, armCol] == a, censorCol])},
                        FUN.VALUE = FALSE)
    if (!all(hasEvents)){
      stop(paste0("The following arms have no events in subgroup '", subgroup, "': ",
                  paste0(armValues[!hasEvents], collapse = ", ")))
    }

    # Create formula for Kaplan-Meier estimator
    formulaToFit <- survivalFormula(armAsFactor=TRUE,
                                    covariates=character(0),
                                    strata=character(0),
                                    timeCol = endPointDef[["timeCol"]],
                                    censorCol = endPointDef[["censorCol"]])

    km <- survfit(formulaToFit,data=survData@subject.data)
    cox <- coxph(formulaToFit,data=survData@subject.data, ties="breslow")

    #fit Cox with strata
    #see note in code of coxphLogRankTest for possible refactoring 
    coxWithStrata <- cox
    if(length(strata)!=0 || length(covariates)!=0){
      formulaToFit <- survivalFormula(armAsFactor=TRUE,
                                      covariates=covariates,
                                      strata=strata,
                                      timeCol = endPointDef[["timeCol"]],
                                      censorCol = endPointDef[["censorCol"]])
      coxWithStrata <- coxph(formulaToFit,data=survData@subject.data, ties="breslow")
    }
    

    new("SemiParametricModel",
        cox=cox,
        coxWithStrata=coxWithStrata,
        km=km,
        survData=survData,
        subgroup=subgroup,
        covariates=covariates,
        strata=strata,
        endPoint=endPoint,
        endPointDef = endPointDef)
  }
)


##' Method to extract the logrank test from the Cox model
##' fit for the SemiParametricModel - this uses the strata and
##' covariates parameters used when creating the SemiParametricModel object
##' @name coxphLogRankTest
##' @rdname coxphLogRankTest-methods
##' @param object (SemiParametricModel) The object which was created when
##' fitting the Cox model
##' @return A dataframe containing the log rank test results
##' @export
setGeneric("coxphLogRankTest", function(object){
  standardGeneric("coxphLogRankTest")
})

##' @name coxphLogRankTest
##' @aliases coxphLogRankTest,SemiParametricModel-method
##' @rdname coxphLogRankTest-methods
##' @export
setMethod("coxphLogRankTest", "SemiParametricModel",function(object){
  #at the moment the only options needed are no strata or a fixed chosen
  #set of stratification variables therefore the slight technical debt gained
  #by changing the previous code to add coxWithStrata slot is deemed acceptable. 
  #If  an additional requirement of being able to select multiple sets of 
  #stratification variables then cox and coxWith strata should be removed
  #from the object and a strata parameter included in this function
  if(length(object@strata)==0){
    return(as.data.frame(t(data.frame(summary(object@cox)[9]))))
  }
  result <- cbind(data.frame(summary(object@cox)[9]),
        data.frame(summary(object@coxWithStrata)[9]))
  
  colnames(result) <- c("No strata/covariates", "With strata/covariates")
  as.data.frame(t(result))
})


##' Method to calculate Cox-Snell residual, using surv(t, e) ~ arm, with no
##' covariates or strata. Data is the subset of data contained in the
##' SemiParametricModel object used.
##' @name coxSnellRes
##' @rdname coxSnellRes-methods
##' @param object (SemiParametricModel) The object which was created when
##' fitting the Cox model
##' @param ... additional parameters needed for specific instances of this
##' generic
##' @return (survfit object) contains call and residuals
##' @export
setGeneric("coxSnellRes", function(object){
  standardGeneric("coxSnellRes")
})

##' @name coxSnellRes
##' @aliases coxSnellRes,SemiParametricModel-method
##' @rdname coxSnellRes-methods
##' @export
setMethod("coxSnellRes", "SemiParametricModel", function(object){

  # Unpack data in object
  timeCol      <- object@endPointDef[["timeCol"]]
  censorCol    <- object@endPointDef[["censorCol"]]
  censorValues <- object@survData@subject.data[, censorCol]
  hasEvent     <- !censorValues

  # Create formula for Kaplan-Meier estimator
  formulaToFit <- survivalFormula(armAsFactor=TRUE,
                                  covariates=character(0),
                                  timeCol = timeCol,
                                  censorCol = censorCol)

  mod <- coxph(formula = formulaToFit,
               data = object@survData@subject.data,
               method = "breslow")

  coxsnell.res <- hasEvent - resid(mod, type="martingale")

  fitres <- survfit(coxph(Surv(coxsnell.res, hasEvent) ~ 1,
                          method="breslow"),
                          type="aalen")
})


# For each arm, extract the data frame of time v probability of survival from
# the survfit object km and rename the "Arm" column of the data frames
# as the armnames (as survfit mangles these)
#
# If outputCI is TRUE then confidence intervals are output
# in the data frames, note these will use the confidence
# level calculated by the model fit (the conf.int argument to survfit
# when km was created, which by default is 0.95)
# Return as a list of data frames, one per arm
extractCumHazData <- function(km, armnames, outputCI=FALSE){

  #Have to convert km$strata (a named vector saying arm 1 is first
  #i rows of data table, arm 2 is next y rows) to a vector with x
  #elements of "arm1" followed by y elements of "arm2"
  strataIndex <- unlist(lapply(seq_along(km$strata),function(i){
    rep(names(km$strata)[i],km$strata[i])
  }))

  #using strataIndex, split the km$surv, km$time vectors
  #into separate arms
  #
  # Result is a list of data frames (one per stratum)
  cumHazData <- lapply(seq_along(names(km$strata)), function(stratCounter){

    #get strata:
    strat <- names(km$strata)[stratCounter]

    #cumulative hazard
    S <- km$surv[strataIndex==strat]
    #time
    t <- km$time[strataIndex==strat]

    #confidence intervals
    lower <- km$lower[strataIndex==strat]
    upper <- km$upper[strataIndex==strat]

    # Curve must start at t = 0, S = 1
    if (length(t) < 1 || t[1] != 0){
      t <- c(0, t)
      S <- c(1, S)
      upper <- c(1, upper)
      lower <- c(1, lower)
    }

    data <- data.frame(t=t,
                       S=S,
                       Arm=rep(armnames[stratCounter], length(S)))
    if(outputCI){
      data <- cbind(data,lower=lower,upper=upper)
    }

    data
  })

  return(cumHazData)
}

